# Способы передачи (uTLS, REALITY)

Способ передачи (transport) — это способ взаимодействия текущего узла Xray с другими узлами.

Транспорт определяет способ передачи данных. Обычно оба конца сетевого подключения должны использовать одинаковый транспорт.
Например, если один конец использует WebSocket, то другой конец также должен использовать WebSocket, иначе соединение не будет установлено.

## StreamSettingsObject

`StreamSettingsObject` соответствует элементу `streamSettings` во входящем или исходящем подключении. Для каждого входящего или исходящего подключения можно настроить различные параметры передачи, и можно использовать `streamSettings` для настройки некоторых параметров передачи.

```json
{
  "network": "raw",
  "security": "none",
  "tlsSettings": {},
  "realitySettings": {},
  "rawSettings": {},
  "xhttpSettings": {},
  "kcpSettings": {},
  "grpcSettings": {},
  "wsSettings": {},
  "httpupgradeSettings": {},
  "sockopt": {
    "mark": 0,
    "tcpMaxSeg": 1440,
    "tcpFastOpen": false,
    "tproxy": "off",
    "domainStrategy": "AsIs",
    "happyEyeballs": {},
    "dialerProxy": "",
    "acceptProxyProtocol": false,
    "tcpKeepAliveInterval": 0,
    "tcpKeepAliveIdle": 300,
    "tcpUserTimeout": 10000,
    "tcpCongestion": "bbr",
    "interface": "wg0",
    "v6only": false,
    "tcpWindowClamp": 600,
    "tcpMptcp": false,
    "tcpNoDelay": false,
    "addressPortStrategy": "",
    "customSockopt": []
  }
}
```

> `network`: "raw" | "xhttp" | "kcp" | "grpc" | "ws" | "httpupgrade"

Тип способа передачи, используемого потоком данных соединения, по умолчанию `"raw"`.

::: tip
**Начиная с версии v24.9.30**, для более точного отражения фактического поведения, тип передачи `tcp` был переименован в `raw`. Для обеспечения совместимости `"network": "raw"` и `"network": "tcp"`, `rawSettings` и `tcpSettings` являются синонимами.
:::

> `security`: "none" | "tls" | "reality"

Включено ли шифрование транспортного уровня, поддерживаемые опции:

- `"none"` означает отсутствие шифрования (значение по умолчанию)
- `"tls"` означает использование [TLS](https://ru.wikipedia.org/wiki/Протокол_защиты_транспортного_уровня).
- `"reality"` означает использование REALITY.

> `tlsSettings`: [TLSObject](#tlsobject)

Конфигурация TLS. TLS предоставляется Golang, обычно результатом согласования TLS является использование TLS 1.3, DTLS не поддерживается.

> `realitySettings`: [RealityObject](#realityobject)

Конфигурация Reality. Reality — это оригинальная технология Xray. Reality обеспечивает более высокий уровень безопасности, чем TLS, и настраивается так же, как TLS.

::: tip
Reality — это самое безопасное на данный момент решение для шифрования передачи данных, и внешний вид трафика такой же, как и при обычном просмотре веб-страниц. Включение Reality и настройка подходящего режима управления потоком XTLS Vision может повысить производительность в несколько раз или даже в десятки раз.
:::

> `rawSettings`: [RawObject](./transports/raw.md)

Конфигурация RAW для текущего соединения, действительна только если это соединение использует RAW.

> `xhttpSettings`: [XHTTP: Beyond REALITY](https://github.com/XTLS/Xray-core/discussions/4113#discussioncomment-11468947)

Конфигурация XHTTP для текущего соединения, действительна только если это соединение использует XHTTP.

> `kcpSettings`: [KcpObject](./transports/mkcp.md)

Конфигурация mKCP для текущего соединения, действительна только если это соединение использует mKCP.

> `grpcSettings`: [GRPCObject](./transports/grpc.md)

Конфигурация gRPC для текущего соединения, действительна только если это соединение использует gRPC.

> `wsSettings`: [WebSocketObject](./transports/websocket.md)

Конфигурация WebSocket для текущего соединения, действительна только если это соединение использует WebSocket.

> `httpupgradeSettings`: [HttpUpgradeObject](./transports/httpupgrade.md)

Конфигурация HTTPUpgrade для текущего соединения, действительна только если это соединение использует HTTPUpgrade.

> `sockopt`: [SockoptObject](#sockoptobject)

Конкретные настройки, связанные с прозрачным проксированием.

### TLSObject

```json
{
  "serverName": "xray.com",
  "verifyPeerCertInNames": "",
  "rejectUnknownSni": false,
  "allowInsecure": false,
  "alpn": ["h2", "http/1.1"],
  "minVersion": "1.2",
  "maxVersion": "1.3",
  "cipherSuites": "Здесь укажите названия необходимых вам наборов шифров, разделяя их двоеточиями",
  "certificates": [],
  "disableSystemRoot": false,
  "enableSessionResumption": false,
  "fingerprint": "chrome",
  "pinnedPeerCertificateChainSha256": [""],
  "curvePreferences": [""],
  "masterKeyLog": "",
  "echConfigList": "",
  "echServerKeys": ""
}
```

> `serverName`: string

Указывает доменное имя сертификата сервера, полезно, когда соединение устанавливается по IP-адресу.

Если оставить пустым, автоматически используется значение из адреса (если это доменное имя), это значение также используется для проверки действительности сертификата сервера.

::: tip
Как упоминалось выше, поскольку это значение также используется для проверки действительности сертификата сервера, если вы измените его на доменное имя, отличное от доменного имени сертификата сервера, необходимо включить `allowInsecure`, иначе произойдет сбой проверки сертификата. Из соображений безопасности мы не рекомендуем использовать этот метод в течение длительного времени. Если вам нужно безопасно подделать SNI, рассмотрите возможность использования REALITY.

В частности, если клиент устанавливает его в IP-адрес, Xray не будет отправлять SNI, и для использования этой функции также необходимо включить `allowInsecure`.
:::

> `verifyPeerCertInNames`: \[ string \]

Только для клиента. Список SNI, используемый для проверки сертификата (достаточно, чтобы хотя бы один SAN из сертификата находился в этом списке). Этот список переопределит `serverName`, который используется для проверки, и предназначен для особых целей, таких как domain fronting. По сравнению с предыдущим методом изменения `serverName` и включения `allowInsecure`, этот способ более безопасен, так как он по-прежнему выполняет проверку подписи сертификата.

Специальное значение `"FromMitM"`: при его использовании в список будет дополнительно добавлен SNI из TLS-трафика, расшифрованного входящим соединением `dokodomo-door`.

> `rejectUnknownSni`: bool

Если значение равно `true`, то сервер отклонит рукопожатие TLS, если полученный SNI не соответствует доменному имени сертификата. По умолчанию равно `false`.

> `alpn`: \[ string \]

Массив строк, указывающий значения ALPN, указанные во время рукопожатия TLS. Значение по умолчанию: `["h2", "http/1.1"]`.

Специальное значение: `["FromMitM"]` (когда это единственный элемент) заставит исходящий TLS использовать ALPN из TLS-соединения, расшифрованного входящим `dokodemo-door`.

> `minVersion`: string

`minVersion` — это минимально допустимая версия TLS.

> `maxVersion`: string

`maxVersion` — это максимально допустимая версия TLS.

> `cipherSuites`: string

`CipherSuites` используется для настройки списка поддерживаемых наборов шифров, разделенных двоеточиями.

Вы можете найти список наборов шифров Golang и их описания [здесь](https://golang.org/src/crypto/tls/cipher_suites.go#L500) или [здесь](https://golang.org/src/crypto/tls/cipher_suites.go#L44).

::: danger
Эти два параметра конфигурации не являются обязательными и обычно не влияют на безопасность. Если они не настроены, Golang автоматически выберет их в зависимости от устройства. Если вы не знакомы с ними, пожалуйста, не настраивайте эти параметры, вы несете ответственность за проблемы, вызванные неправильным заполнением.
:::

> `allowInsecure`: true | false

Разрешить ли небезопасные соединения (только для клиента). Значение по умолчанию: `false`.

Если значение равно `true`, то Xray не будет проверять действительность сертификата TLS, предоставленного удаленным хостом.

::: danger
Из соображений безопасности этот параметр не следует устанавливать в значение `true` в реальных сценариях, иначе вы можете подвергнуться атаке типа «человек посередине».
:::

> `disableSystemRoot`: true | false

Отключить ли корневые сертификаты операционной системы. Значение по умолчанию: `false`.

Если значение равно `true`, то Xray будет использовать только сертификаты, указанные в `certificates`, для рукопожатия TLS. Если значение равно `false`, то Xray будет использовать только корневые сертификаты операционной системы для рукопожатия TLS.

> `enableSessionResumption`: true | false

Включить ли восстановление сессии. По умолчанию отключено, и оно будет работать только в том случае, если как сервер, так и клиент поддерживают эту функцию и активировали её.

Если восстановление сессии будет успешно согласовано, передача сертификатов во время рукопожатия станет необязательной. Это может немного сократить время на рукопожатие (разница практически незаметна).

Обратите внимание, что это не TLS 0RTT. Функция TLS 0RTT пока не поддерживается в gotls, и это не уменьшит количество RTT в процессе TLS-рукопожатия.

> `fingerprint` : string

Этот параметр используется для настройки указанного отпечатка `TLS Client Hello`.

Значение по умолчанию `chrome` .

При включении Xray будет **эмулировать** отпечаток `TLS` через библиотеку uTLS или генерировать его случайным образом.
Поддерживаются четыре режима настройки:

1. Отпечатки TLS последних версий популярных браузеров, включая:

- `"chrome"`
- `"firefox"`
- `"safari"`
- `"ios"`
- `"android"`
- `"edge"`
- `"360"`
- `"qq"`

2. Автоматическая генерация отпечатка при запуске Xray:

- `"random"`: случайный выбор из новых версий браузеров.
- `"randomized"`: полная случайная генерация уникального отпечатка (100% поддержка TLS 1.3 с использованием X25519)

3. Использование имени переменной отпечатка uTLS, например, `"HelloRandomizedNoALPN"` `"HelloChrome_106_Shuffle"`. Полный список см. в [библиотеке uTLS](https://github.com/refraction-networking/utls/blob/master/u_common.go#L434).

4. Отключение **эмуляции** отпечатка `TLS Client Hello`

::: danger
Из соображений безопасности этот параметр не следует устанавливать в значение `unsafe`.
:::

- `"unsafe"`: отпечаток go/tls

::: tip
Эта функция только **эмулирует** отпечаток `TLS Client Hello`, поведение и другие отпечатки такие же, как у Golang. Если вам нужна более полная эмуляция отпечатка и поведения браузера `TLS`, используйте [Browser Dialer](./transports/websocket.md#browser-dialer).
:::

::: tip
При использовании этой функции некоторые параметры TLS, влияющие на отпечаток TLS, будут переопределены библиотекой utls и не будут действовать, например, ALPN.
Передаваемые параметры:
`"serverName" "allowInsecure" "disableSystemRoot" "pinnedPeerCertificateChainSha256" "masterKeyLog"`
:::

> `pinnedPeerCertificateChainSha256`: \[string\]

Используется для указания хэша SHA256 цепочки сертификатов удаленного сервера с использованием стандартного формата кодировки. Соединение TLS может быть успешно установлено только в том случае, если хэш цепочки сертификатов сервера соответствует одному из значений, указанных в настройке.

Если соединение не удалось установить из-за этой конфигурации, будет отображен хэш сертификата удаленного сервера.

**Примечание:** Проверка будет выполняться только после успешной проверки сертификата на действительность. Например, если используется самоподписанный сертификат и он указан здесь, то при неудачной проверке сертификата ядро сразу разорвет соединение и не будет выполнять эту проверку. В подобных случаях можно рассмотреть включение параметра `allowInsecure`, чтобы пропустить проверку подписи, что позволит системе работать корректно.

::: danger
Не рекомендуется использовать этот способ для получения хэша цепочки сертификатов, так как в этом случае не будет возможности проверить, является ли сертификат, предоставленный сервером в данный момент, подлинным, и, следовательно, не гарантируется, что полученный хэш сертификата является ожидаемым.
:::

::: tip
Если вам нужно получить хэш сертификата, запустите `xray tls certChainHash --cert <cert.pem>` из командной строки, где `<cert.pem>` следует заменить на фактический путь к файлу сертификата.
:::

> `certificates`: \[ [CertificateObject](#certificateobject) \]

Список сертификатов, каждый элемент которого представляет собой сертификат (рекомендуется fullchain).

::: tip
Если вам нужно получить оценку A/A+ в ssllibs или myssl,
пожалуйста, обратитесь к [этому](https://github.com/XTLS/Xray-core/discussions/56#discussioncomment-215600).
:::

> `curvePreferences`: \[ string \]

Массив строк, задающий предпочтительные кривые для выполнения ECDHE во время TLS-рукопожатия. Список поддерживаемых кривых приведён ниже (регистр не имеет значения):
CurveP256
CurveP384
CurveP521
X25519
x25519Kyber768Draft00

Например, установка значения `"curvePreferences":["x25519Kyber768Draft00"]` позволяет включить экспериментальный алгоритм. Поскольку этот алгоритм находится на стадии черновика, данное поле может измениться в любой момент.

> `masterKeyLog` : string

Файл журнала (Pre)-Master-Secret, путь к которому задаётся здесь, может быть использован в Wireshark и других программах для расшифровки TLS-соединений, устанавливаемых Xray.

> `echConfigList` : string

Только для клиента. Задаёт ECHConfig; если значение задано — клиент включает Encrypted Client Hello. Поддерживаются два формата.

Фиксированный ECHConfig, например `"AF7+DQBaAAAgACA51i3Ssu4wUMV4FNCc8iRX5J+YC4Bhigz9sacl2lCfSQAkAAEAAQABAAIAAQADAAIAAQACAAIAAgADAAMAAQADAAIAAwADAAtleGFtcGxlLmNvbQAA"`

Получение через DNS. Удобно при использовании CDN: по HTTPS-записи можно динамически получить ECHConfig; Xray будет соблюдать TTL, возвращённый сервером. Запрашивается SNI из конфигурации или доменное имя сервера (если SNI пуст и целью является домен).

Базовый вид строки: `"udp://1.1.1.1"` — запрос по UDP DNS к 1.1.1.1. `"https://1.1.1.1/dns-query"` — запрос по DoH (пример; замените на доступный сервер). В обоих случаях можно указать порт, например `udp://1.1.1.1:53`; если порт не указан, берутся значения по умолчанию 53/443.

Особый случай: можно задать домен, из чьей записи будет браться ECHConfig, например `"example.com+https://1.1.1.1/dns-query"`. Тогда Xray принудительно использует ECHConfig из DNS-записи example.com, что полезно, если нужно получить ECHConfig через DNS, но не хочется светить целевой домен в HTTPS-запросе или публиковать у него HTTPS-запись.

> `echServerKeys` : string

Только для сервера. Включает Encrypted Client Hello на стороне сервера.

Создайте ключи командой `xray tls ech --serverName example.com` где `example.com` — SNI, который будет открыт наружу (можно указать любой). Server Key содержит и ECHConfig; если клиентский Config потерян, его можно восстановить командой `xray tls ech -i "ваш server key"`.
Полученный Config можно опубликовать в HTTPS-записи DNS (см. пример в [Google DNS](https://dns.google/query?name=encryptedsni.com&rr_type=HTTPS) или RFC 9460).

Учтите: сервер, настроенный на использование ECH, всё ещё принимает обычные не-ECH-соединения. Но клиент, настроенный на ECH, при неудачной ECH-рукопожатии сразу завершит соединение, не откатываясь к открытому SNI.

### RealityObject

```json
{
  "show": false,
  "target": "example.com:443",
  "xver": 0,
  "serverNames": ["example.com", "www.example.com"],
  "privateKey": "",
  "minClientVer": "",
  "maxClientVer": "",
  "maxTimeDiff": 0,
  "shortIds": ["", "0123456789abcdef"],
  "mldsa65Seed": "",
  "limitFallbackUpload": {
    "afterBytes": 0,
    "bytesPerSec": 0,
    "burstBytesPerSec": 0
  },
  "limitFallbackDownload": {
    "afterBytes": 0,
    "bytesPerSec": 0,
    "burstBytesPerSec": 0
  },
  "fingerprint": "chrome",
  "serverName": "",
  "password": "",
  "shortId": "",
  "mldsa65Verify": "",
  "spiderX": ""
}
```

::: tip
Дополнительную информацию см. в проекте [REALITY](https://github.com/XTLS/REALITY).
:::

::: tip
Reality лишь модифицирует TLS, и для реализации на стороне клиента достаточно незначительных изменений — полностью случайного session id и кастомной проверки сертификатов. Теоретически это полностью совместимо с большинством TLS-реализаций.

Однако это не работает с QUIC, так как поле session id, которое требуется изменить в Reality, в практически всех реализациях TCP TLS заполняется случайными значениями для совместимости, но в QUIC TLS это поле имеет нулевую длину и не может быть модифицировано.
:::

> `show` : true | false

Если значение равно `true`, выводить отладочную информацию.

::: tip
Ниже приведена конфигурация для **входящего** подключения (**сервера**).
:::

> `target` : string

Обязательный параметр, формат такой же, как у [dest](./features/fallback.md#fallbackobject) в VLESS `fallbacks`.

Если целевой сервер поддерживает пост-квантовый алгоритм обмена ключами X25519MLKEM768, то клиент reality автоматически применит этот алгоритм для согласования ключей. Чтобы проверить поддержку, выполните команду `xray tls ping cloudflare.com` (замените адрес на `dest`, при необходимости добавьте номер порта).

::: warning
Из соображений маскировки Xray будет **непосредственно перенаправлять** трафик с неудачной аутентификацией (недопустимый запрос REALITY) на `dest`.
Если IP-адрес сайта `dest` особый (например, сайт использует CloudFlare CDN), это равносильно тому, что ваш сервер действует как port forward для CloudFlare, что может привести к злоупотреблению.

Чтобы этого избежать, можно рассмотреть возможность использования Nginx и других методов для фильтрации нежелательных SNI.
Или вы также можете рассмотреть настройку соответствующих параметров `limitFallbackUpload` и `limitFallbackDownload`, чтобы ограничить скорость.
:::

> `xver` : number

Необязательный параметр, формат такой же, как у [xver](./features/fallback.md#fallbackobject) в VLESS `fallbacks`.

> `serverNames` : \[string\]

Обязательный параметр, список доступных `serverName` для клиента, подстановочные знаки \* пока не поддерживаются.

Обычно он совпадает с `dest`, фактическое допустимое значение — это любой SNI, принимаемый сервером (в зависимости от конфигурации `dest`), в качестве справки можно использовать [SAN](https://ru.wikipedia.org/wiki/Subject_Alternative_Name) возвращаемого сертификата.

Может содержать пустое значение `""`, что означает принятие соединений без SNI.

> `privateKey` : string

Обязательный параметр, генерируется с помощью команды `./xray x25519`.

> `minClientVer` : string

Необязательный параметр, минимальная версия Xray клиента, формат: `x.y.z`.

> `maxClientVer` : string

Необязательный параметр, максимальная версия Xray клиента, формат: `x.y.z`.

> `maxTimeDiff` : number

Необязательный параметр, максимально допустимая разница во времени в миллисекундах.

> `shortIds` : \[string\]

Обязательный параметр, список доступных `shortId` для клиента, можно использовать для различения разных клиентов.

Требования к формату см. в `shortId`.

Если содержит пустое значение, `shortId` клиента может быть пустым.

> `mldsa65Seed` : string

Только для сервера. Приватный ключ, применяемый для добавления к сертификату, выдаваемому клиенту Reality, дополнительной пост-квантовой подписи по схеме ML-DSA-65. Назначение — защитить соединение на случай появления квантового компьютера, способного взломать X25519: даже если пароль будет скомпрометирован, MITM-атака останется невозможной.

Сгенерировать пару ключей можно командой `xray mldsa65`. После того как приватный ключ внесён в конфигурацию сервера, подпись добавляется в расширение сертификата; на старые клиенты или клиенты без поддержки этой функции это не влияет.

После включения этой функции длина сертификата, возвращаемого целевым сервером (target), **обязательно** должна превышать 3500 байт. Пост-квантовая подпись увеличивает размер временного сертификата Reality; чтобы не создавать отличительную особенность, сертификат target тоже должен быть крупным. Проверить размер можно командой `xray tls ping example.com`.
Для полной пост-квантовой защиты сам target также должен поддерживать ключевой обмен X25519MLKEM768. Поддержку можно проверить той же командой, указанной выше.

> `limitFallbackUpload`/`limitFallbackDownload`

::: warning
Предупреждение: Лучшей практикой для REALITY всегда является использование сертификата из той же ASN, поэтому, скорее всего, вам эта функция не понадобится; только если вы вынуждены использовать сертификат CDN, можно рассмотреть включение этой функции, чтобы избежать превращения вашего сервера в узел для других.

Включение ограничения скорости может ввести новые характеристики, обнаруживаемые GFW! Если вы разработчик GUI/панели/скрипта установки в один клик, обязательно рандомизируйте эти параметры!
:::

::: tip
`limitFallbackUpload` и `limitFallbackDownload` являются необязательными параметрами. Они позволяют ограничить скорость передачи данных для резервных (fallback) соединений, не прошедших проверку. Параметр `bytesPerSec` по умолчанию равен 0, что означает, что ограничение скорости не включено.

Принцип работы: Для каждого соединения алгоритм ограничения скорости включается после передачи `afterBytes` байтов.

Ограничение скорости реализовано с помощью алгоритма "маркерная корзина" (token bucket). Вместимость корзины равна `burstBytesPerSec`. Каждый переданный байт потребляет один маркер, и изначально корзина заполнена до `burstBytesPerSec`.

Каждую секунду корзина пополняется на `bytesPerSec` маркеров, пока не достигнет своей максимальной вместимости.

Пример: `afterBytes=10485760`, `burstBytesPerSec=5242880`, `bytesPerSec=1048576` означают, что после передачи 10 МB скорость будет ограничена до 1 МB/с. Если передача приостановится, через 5 секунд скорость может временно вырасти до 5 МB/с (burst), а затем снова вернется к 1 МB/с.

Рекомендации: Слишком большие значения `afterBytes` и `burstBytesPerSec` не приведут к желаемому эффекту ограничения скорости. Слишком маленькие значения `bytesPerSec` и `burstBytesPerSec` могут быть легко обнаружены.

Следует разумно подбирать параметры в зависимости от размера ресурсов веб-сайта-источника. Если внезапные скачки скорости нежелательны, установите для `burstBytesPerSec` значение 0. :::

> `afterBytes` : number

Необязательный параметр. Ограничение скорости для резервных соединений REALITY. Ограничение вступает в силу после передачи указанного количества байт. По умолчанию 0.

> `bytesPerSec` : number

Необязательный параметр. Ограничение скорости для резервных соединений REALITY. Задаёт базовую скорость (байт/секунду). По умолчанию 0, что означает отключение функции ограничения скорости.

> `burstBytesPerSec` : number

Необязательный параметр. Ограничение скорости для резервных соединений REALITY. Задаёт пиковую (burst) скорость (байт/секунду). Действует, когда значение больше `bytesPerSec`.

::: tip
Ниже приведена конфигурация для **исходящего** подключения (**клиента**).
:::

> `serverName` : string

Один из `serverNames` сервера.

Если `serverNames` сервера содержит пустое значение, то, как и в случае с TLS, клиент может использовать `"serverName": "0.0.0.0"` для установления соединения без SNI. В отличие от TLS, REALITY не требует и не имеет опции разрешения небезопасных соединений для этой функции. При использовании этой функции убедитесь, что `dest` возвращает сертификат по умолчанию при принятии соединений без SNI.

> `fingerprint` : string

Обязательный параметр, такой же, как в [TLSObject](#tlsobject).

> `shortId` : string

Один из `shortIds` сервера.

Длина — 8 байт, то есть 16 шестнадцатеричных цифр (0-f), может быть меньше 16, ядро автоматически добавит 0 в конец, но количество цифр должно быть **четным** (потому что один байт состоит из 2 шестнадцатеричных цифр).

Например, `aa1234` будет автоматически дополнено до `aa12340000000000`, а `aaa1234` приведет к ошибке.

0 также является четным числом, поэтому, если `shordIDs` сервера содержит пустое значение `""`, клиент также может быть пустым.

> `password` : string

Обязательный параметр: публичный ключ, соответствующий приватному ключу сервера. Генерируется командой  
`./xray x25519 -i "серверный приватный ключ"`.

Ранее назывался `publicKey`, однако во избежание недоразумений переименован (формально это X25519-публичный ключ, но в концепции Reality он хранится у клиента и не должен публиковаться).

> `mldsa65Verify` : string

Необязательный параметр. Публичный ключ для проверки подписи ML-DSA-65.  
Если поле не пустое, клиент будет использовать указанный ключ для валидации сертификата, возвращённого сервером. Подробности см. в описании параметра `"mldsa65Seed"`.

> `spiderX` : string

Начальный путь и параметры для краулера, рекомендуется использовать разные для каждого клиента.

#### CertificateObject

```json
{
  "ocspStapling": 0,
  "oneTimeLoading": false,
  "usage": "encipherment",
  "buildChain": false,
  "certificateFile": "/path/to/certificate.crt",
  "keyFile": "/path/to/key.key",
  "certificate": [
    "--BEGIN CERTIFICATE--",
    "MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw",
    "ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3",
    "DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+",
    "3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw",
    "OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5",
    "pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON",
    "OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp",
    "noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G",
    "A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA",
    "MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU",
    "7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+",
    "9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO",
    "6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8",
    "r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/",
    "d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q",
    "--END CERTIFICATE--"
  ],
  "key": [
    "--BEGIN RSA PRIVATE KEY--",
    "MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh",
    "bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9",
    "GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n",
    "jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN",
    "itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq",
    "IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw",
    "qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue",
    "C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap",
    "/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM",
    "aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW",
    "/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4",
    "bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ",
    "8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi",
    "pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR",
    "L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG",
    "3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7",
    "az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK",
    "gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH",
    "TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8",
    "eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW",
    "64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q",
    "8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2",
    "GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq",
    "ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR",
    "cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT",
    "--END RSA PRIVATE KEY--"
  ]
}
```

Сертификат сервера будет автоматически перезагружаться каждые 3600 секунд (то есть каждый час).

> `ocspStapling`: number

Интервал обновления OCSP Stapling в секундах, по умолчанию 0. Любое ненулевое значение включит OCSP Stapling и переопределит время горячей перезагрузки сертификата по умолчанию в 3600 секунд (OCSP Stapling выполняется во время перезагрузки).

> `oneTimeLoading`: true | false

Загружать только один раз, по умолчанию `false`. Если значение `true`, функции горячей перезагрузки сертификата и OCSP Stapling будут отключены.

::: warning
Если значение равно `true`, то OCSP-Stapling будет отключено.
:::

> `usage`: "encipherment" | "verify" | "issue"

Использование сертификата, значение по умолчанию: `"encipherment"`.

- `"encipherment"`: сертификат используется для аутентификации и шифрования TLS.
- `"verify"`: сертификат используется для проверки сертификата удаленного TLS. При использовании этого значения текущий сертификат должен быть сертификатом ЦС.
- `"issue"`: сертификат используется для выпуска других сертификатов. При использовании этого значения текущий сертификат должен быть сертификатом ЦС.

::: tip СОВЕТ 1
В Windows вы можете установить самоподписанный сертификат ЦС в систему, чтобы проверить сертификат удаленного TLS.
:::

::: tip СОВЕТ 2
Когда поступает новый запрос от клиента, предполагая, что указанный `serverName` равен `"xray.com"`, Xray сначала ищет в списке сертификатов сертификат, который можно использовать для `"xray.com"`, и, если он не найден, использует любой сертификат с `usage`, равным `"issue"`, для выпуска сертификата, подходящего для `"xray.com"`, со сроком действия один час. Новый сертификат будет добавлен в список сертификатов для последующего использования.
:::

::: tip СОВЕТ 3
Если одновременно указаны `certificateFile` и `certificate`, Xray отдает приоритет `certificateFile`. То же самое касается `keyFile` и `key`.
:::

::: tip СОВЕТ 4
Когда `usage` равно `"verify"`, то `keyFile` и `key` могут быть пустыми.
:::

::: tip СОВЕТ 5
Используйте `xray tls cert` для генерации самоподписанного сертификата ЦС.
:::

::: tip СОВЕТ 6
Если у вас уже есть доменное имя, вы можете использовать инструменты для удобного получения бесплатных сторонних сертификатов, например, [acme.sh](https://github.com/acmesh-official/acme.sh).
:::

> `buildChain`: true | false

Вступает в силу только при использовании сертификата `"issue"`, если значение равно `true`, то сертификат ЦС будет встроен в цепочку сертификатов при выпуске сертификата.

::: tip СОВЕТ 1
Не следует встраивать корневой сертификат в цепочку сертификатов. Этот параметр следует включать только при подписании сертификата ЦС в качестве промежуточного сертификата.
:::

> `certificateFile`: string

Путь к файлу сертификата, например, сгенерированному с помощью OpenSSL, с расширением .crt.

> `certificate`: \[ string \]

Массив строк, представляющий содержимое сертификата, формат см. в примере. Используйте либо `certificate`, либо `certificateFile`.

> `keyFile`: string

Путь к файлу ключа, например, сгенерированному с помощью OpenSSL, с расширением .key. В настоящее время не поддерживаются файлы ключей, защищенные паролем.

> `key`: \[ string \]

Массив строк, представляющий содержимое ключа, формат см. в примере. Используйте либо `key`, либо `keyFile`.

### SockoptObject

```json
{
  "mark": 0,
  "tcpMaxSeg": 1440,
  "tcpFastOpen": false,
  "tproxy": "off",
  "domainStrategy": "AsIs",
  "dialerProxy": "",
  "happyEyeballs": {},
  "acceptProxyProtocol": false,
  "tcpKeepAliveInterval": 0,
  "tcpKeepAliveIdle": 300,
  "tcpUserTimeout": 10000,
  "tcpcongestion": "bbr",
  "interface": "wg0",
  "V6Only": false,
  "tcpWindowClamp": 600,
  "tcpMptcp": false,
  "tcpNoDelay": false,
  "customSockopt": []
}
```

> `mark`: number

Целое число. Если значение не равно нулю, то исходящее соединение помечается этим значением с помощью SO_MARK.

- Работает только в Linux.
- Требуются права CAP_NET_ADMIN.

> `tcpMaxSeg`: number

Используется для установки максимального сегмента TCP-пакета (Maximum Segment Size).

> `tcpFastOpen`: true | false | number

Включить [TCP Fast Open](https://ru.wikipedia.org/wiki/TCP_Fast_Open).

Если значение равно `true` или **положительному целому числу**, то TFO включается; если значение равно `false` или **отрицательному числу**, то TFO принудительно отключается; если параметр отсутствует или равен `0`, то используются настройки системы по умолчанию. Можно использовать как для входящих, так и для исходящих подключений.

- Доступно только в следующих (или более новых) версиях операционных систем:
  - Linux 3.16: требуется настройка параметра ядра `net.ipv4.tcp_fastopen`, который представляет собой битовую маску, где `0x1` означает, что клиент может включать TFO, а `0x2` означает, что сервер может включать TFO; значение по умолчанию — `0x1`, если серверу необходимо включить TFO, установите значение этого параметра ядра в `0x3`.
  - ~~Windows 10 (1607)~~ (реализовано неправильно)
  - Mac OS 10.11 / iOS 9 (требуется тестирование)
  - FreeBSD 10.3 (Server) / 12.0 (Client): необходимо установить параметры ядра `net.inet.tcp.fastopen.server_enabled` и `net.inet.tcp.fastopen.client_enabled` в значение `1`. (Требуется тестирование)

- Для входящих подключений установленное здесь **положительное целое число** представляет собой [максимальное количество ожидающих запросов на подключение TFO](https://tools.ietf.org/html/rfc7413#section-5.1), **обратите внимание, что не все операционные системы поддерживают эту настройку**:
  - Linux / FreeBSD: установленное здесь **положительное целое число** представляет собой максимальное значение, максимально допустимое значение — 2147483647, если установлено значение `true`, то используется значение `256`; обратите внимание, что в Linux `net.core.somaxconn` ограничивает максимальное значение, если оно превышает `somaxconn`, то необходимо также увеличить `somaxconn`.
  - Mac OS: если здесь установлено значение `true` или **положительное целое число**, это означает только включение TFO, максимальное значение необходимо установить отдельно с помощью параметра ядра `net.inet.tcp.fastopen_backlog`.
  - Windows: если здесь установлено значение `true` или **положительное целое число**, это означает только включение TFO.

- Для исходящих подключений установка значения `true` или **положительного целого числа** в любой операционной системе означает только включение TFO.

> `tproxy`: "redirect" | "tproxy" | "off"

Включить ли прозрачное проксирование (только для Linux).

- `"redirect"`: использовать прозрачное проксирование в режиме перенаправления. Поддерживаются все TCP-соединения на основе IPv4/6.
- `"tproxy"`: использовать прозрачное проксирование в режиме TProxy. Поддерживаются все TCP- и UDP-соединения на основе IPv4/6.
- `"off"`: отключить прозрачное проксирование.

Для прозрачного проксирования требуются права root или `CAP_NET_ADMIN`.

::: danger
Если в [Dokodemo-door](./inbounds/dokodemo.md) указано `followRedirect: true` и `tproxy` в настройках Sockopt пуст, то значение `tproxy` в настройках Sockopt будет установлено в `"redirect"`.
:::

> `domainStrategy`: "AsIs"
> "UseIP" | "UseIPv6v4" | "UseIPv6" | "UseIPv4v6" | "UseIPv4"
> "ForceIP" | "ForceIPv6v4" | "ForceIPv6" | "ForceIPv4v6" | "ForceIPv4"

В предыдущих версиях, когда Xray пытался установить системное соединение с использованием доменного имени, разрешение доменного имени выполнялось системой и не контролировалось Xray. Это приводило к таким проблемам, как [невозможность разрешить доменные имена в нестандартных средах Linux](https://github.com/v2ray/v2ray-core/issues/1909). Для решения этой проблемы в Xray 1.3.1 в Sockopt был добавлен параметр `domainStrategy` в разделе Freedom.

Значение по умолчанию: `"AsIs"`.

Если целевой адрес представлен доменным именем, можно настроить соответствующее значение. Поведение Freedom в зависимости от настройки следующее:

- При использовании `"AsIs"` Xray будет напрямую использовать встроенную функцию `Dial` из Go для установления соединения, с фиксированным приоритетом, заданным по умолчанию в RFC6724 (игнорируя такие настройки, как `gai.conf`). _(Простыми словами: IPv6 будет использоваться с приоритетом.)_
- При использовании другого значения будет применен [встроенный DNS-сервер](../dns.md) Xray-core для разрешения доменного имени.
  Если объект `DNSObject` отсутствует, будет использоваться системный DNS. Если существует несколько подходящих IP-адресов, ядро выберет один из них случайным образом.
- `"IPv4"` означает попытку установить соединение, используя только IPv4,
  `"IPv4v6"` означает попытку соединения с использованием IPv4 или IPv6, но для доменов с двойным стеком будет использоваться IPv4.
  _(Если поменять местами v4 и v6, логика остается аналогичной)_
- Если во встроенном DNS установлен параметр `"queryStrategy"`, то фактическое поведение будет комбинацией с этим параметром, и будут разрешаться только типы IP-адресов, присутствующие в обоих параметрах. Например:
  `"queryStrategy": "UseIPv4"` и `"domainStrategy": "UseIP"` фактически эквивалентны `"domainStrategy": "UseIPv4"`.

::: tip TIP
При использовании режимов `"UseIP"` и `"ForceIP"` и если в [конфигурации исходящего подключения](../outbound.md#outboundobject) указан `sendThrough`, ядро автоматически определит необходимый тип IP (IPv4 или IPv6) на основе значения `sendThrough`. Если вручную указан один тип IP (например, UseIPv4), но он не соответствует локальному адресу, указанному в `sendThrough`, подключение завершится неудачно.
:::

::: danger
Неправильная конфигурация после включения этой функции может привести к бесконечному циклу.

Кратко: для подключения к серверу необходимо дождаться результата DNS-запроса; для завершения DNS-запроса необходимо подключиться к серверу.

> Tony: Что было раньше, курица или яйцо?

Подробное объяснение:

1. Условие возникновения: прокси-сервер (proxy.com). Встроенный DNS-сервер, режим не Local.
2. Xray пытается установить TCP-соединение с proxy.com **до** того, как запросит proxy.com через встроенный DNS-сервер.
3. Встроенный DNS-сервер устанавливает соединение с dns.com и отправляет запрос для получения IP-адреса proxy.com.
4. **Неправильные** правила маршрутизации приводят к тому, что proxy.com проксирует запрос, отправленный на шаге 3.
5. Xray пытается установить другое TCP-соединение с proxy.com.
6. Перед установкой соединения запрашивает proxy.com через встроенный DNS-сервер.
7. Встроенный DNS-сервер повторно использует соединение с шага 3 и отправляет запрос.
8. Возникает проблема. Установка соединения на шаге 3 требует ожидания результата запроса на шаге 7; завершение запроса на шаге 7 требует полного установления соединения на шаге 3.
9. Игра окончена!

Решение:

- Изменить правила маршрутизации для встроенного DNS-сервера.
- Использовать Hosts.
- ~~Если вы все еще не знаете решения, не используйте эту функцию.~~

Поэтому **не рекомендуется** неопытным пользователям самостоятельно использовать эту функцию.
:::

> `dialerProxy`: ""

Идентификатор исходящего прокси. Если значение не пустое, для установления соединения будет использоваться указанный outbound. Эта опция может быть использована для поддержки цепочной переадресации на уровне транспорта.

::: danger
Эта опция несовместима с ProxySettingsObject.Tag
:::

> `acceptProxyProtocol`: true | false

Только для inbound, указывает, следует ли принимать PROXY protocol.

[PROXY protocol](https://www.haproxy.org/download/2.2/doc/proxy-protocol.txt) предназначен для передачи реального исходного IP-адреса и порта запроса. **Если вы не знакомы с ним, проигнорируйте этот параметр**.

Распространенное программное обеспечение обратного прокси (например, HAProxy, Nginx) может быть настроено на его отправку, VLESS fallbacks xver также может его отправлять.

Если установлено значение `true`, после установления TCP-соединения на самом нижнем уровне, запрашивающая сторона должна сначала отправить PROXY protocol v1 или v2, иначе соединение будет закрыто.

> `tcpKeepAliveIdle`: number

Порог времени простоя TCP в секундах. Когда время простоя TCP-соединения достигает этого порога, начинают отправляться Keep-Alive пакеты.

Для исходящего трафика Xray использует значения по умолчанию из Chrome: как `idle`, так и `interval` равны 45 с. Если этот параметр или `tcpKeepAliveInterval` установить в отрицательное значение, стандартный keep-alive будет отключён; положительное же значение перезапишет настройку по умолчанию.

Для входящего трафика Keep-Alive по умолчанию отключён; он будет активирован, если любой из этих параметров или `tcpKeepAliveInterval` имеет ненулевое значение. Если указан только один из них, второй примет значение, заданное операционной системой.

> `tcpKeepAliveInterval`: number

Интервал (в секундах) между отправками keep-alive-пакетов после того, как TCP-соединение перешло в состояние Keep-Alive. Остальное поведение описано выше.

> `tcpUserTimeout`: number

В миллисекундах. Подробнее: https://github.com/grpc/proposal/blob/master/A18-tcp-user-timeout.md

> `tcpcongestion`: ""

Алгоритм управления перегрузкой TCP. Поддерживается только в Linux.
Если этот параметр не настроен, используется значение по умолчанию системы.

::: tip Распространенные алгоритмы

- bbr (рекомендуется)
- cubic
- reno

:::

::: tip
Выполните команду `sysctl net.ipv4.tcp_congestion_control`, чтобы получить значение по умолчанию системы.
:::

> `interface`: ""

Указывает имя сетевого интерфейса для исходящего трафика. Поддерживается в Linux, iOS, macOS и Windows.

> `V6Only`: true | false

Если установлено значение `true`, адрес `::` принимает только IPv6-соединения. Поддерживается только в Linux.

> `tcpWindowClamp`: number

Объявленный размер окна ограничен этим значением. Ядро выберет максимальное значение между этим значением и SOCK_MIN_RCVBUF/2.

> `tcpMptcp`: true | false

По умолчанию этот параметр имеет значение `false`. Установите его в `true`, чтобы включить [Multipath TCP](https://en.wikipedia.org/wiki/Multipath_TCP).

Обратите внимание, что этот параметр действует только на стороне клиента. В Golang версии 1.24 и выше MPTCP уже включен по умолчанию на стороне сервера (при прослушивании соединений).

Для работы MPTCP требуется Linux с ядром версии 5.6 или новее.

> `tcpNoDelay`: true | false

Этот параметр удален, так как golang по умолчанию включает TCP no delay. Если вы хотите отключить его, используйте customSockopt.

> `addressPortStrategy`: "none" | "SrvPortOnly" | "SrvAddressOnly" | "SrvPortAndAddress" | "TxtPortOnly" | "TxtAddressOnly" | "TxtPortAndAddress"

Использование SRV или TXT записей для определения целевого адреса/порта исходящего трафика. По умолчанию `none` (отключено).

Запросы DNS выполняются через системный DNS (не через встроенный DNS Xray). Домен для DNS запроса определяется настройками исходящего подключения. Если DNS запрос не удался, трафик отправляется по исходному адресу и порту.

Префикс `Srv` указывает на запрос SRV-записей (стандартный формат), префикс `Txt` - на запрос TXT-записей (формат вида `127.0.0.1:80`).

`PortOnly`: Сброс только порта.
`AddressOnly`: Сброс только адреса.
`PortAndAddress`: Сброс адреса и порта.

Важно! Данная настройка применяется _до_ этапа выбора стратегии разрешения доменов (`domainStrategy`) в `sockopt`. После сброса адреса продолжает действовать `domainStrategy` (если она активна), но _после_ того, как `domainStrategy` в `Freedom` уже отработала. Если в `Freedom` настроено явное разрешение в IP-адрес, данная опция не оказывает никакого эффекта.

PS: Если трафик домена, например, обычный веб-трафик, маршрутизируется через `Freedom` с установленной стратегией `AsIs`, то при активации этой опции будет предпринята попытка разрешить домен и сбросить адрес/порт в соответствии с полученными данными. Например, ядро Xray попытается запросить SRV-запись для `google.com` и перенаправить трафик, опираясь на информацию из этой записи.

> `customSockopt`: []

Массив, позволяющий опытным пользователям указывать любые необходимые sockopt. Теоретически все вышеперечисленные настройки, связанные с соединением, могут быть эквивалентно настроены здесь. В настоящее время поддерживаются операционные системы Linux, Windows, Darwin. Приведенный ниже пример эквивалентен `"tcpcongestion": "bbr"` в ядре.

Перед использованием убедитесь, что вы понимаете программирование сокетов Linux.

```json
"customSockopt": [
  {
    "system": "linux",
    "type": "str",
    "level":"6",
    "opt": "13",
    "value": "bbr"
  }
]
```

> `system`: ""

Необязательное поле. Указывает операционную систему, для которой будет применяться данная опция. Если текущая операционная система не совпадает с указанной, эта опция (`sockopt`) будет пропущена. В настоящее время доступны значения: `linux`, `windows`, `darwin` (все в нижнем регистре). Если оставить пустым, опция будет применена независимо от операционной системы.

> `type`: ""

Обязательный параметр. Тип настройки. Допустимые значения: int или str.

> `level`: ""

Необязательный параметр. Уровень протокола, определяющий область действия. По умолчанию: 6 (TCP).

> `opt`: ""

Название опции, которую нужно установить. Используется десятичное представление (в примере, значение TCP_CONGESTION, определенное как 0xd, преобразуется в десятичное 13).

> `value`: ""

Значение, которое нужно установить для опции. В примере устанавливается значение bbr.

Если `type` указан как int, значение должно быть десятичным числом.

> `happyEyeballs`: map

Реализация happyEyeballs по RFC-8305 применима только к TCP. Когда целью является доменное имя, она запускает "гонку" между IP-адресами и выбирает первый, с которым удалось установить соединение. Это работает, когда `domainStrategy` установлен на `UseIP`/`ForceIP` (включая их v4/v6/v4v6 версии, но это сокращает список доступных IP-адресов только до v4 или v6, что не рекомендуется).

::: warning
При использовании этой функции не используйте `domainStrategy` для исходящего соединения `Freedom`, так как это приведет к тому, что `Sockopt` будет видеть только конечный, уже выбранный IP-адрес.
:::

```json
"happyEyeballs": {
    "tryDelayMs": 250,
    "prioritizeIPv6": false,
    "interleave": 1,
    "maxConcurrentTry": 4,
}
```

> `tryDelayMs`: number

Интервал времени между каждым запросом "гонки", в миллисекундах. По умолчанию 0 (что означает, что функция отключена), рекомендуемое значение — 250.

> `prioritizeIPv6`: bool

Тип первого IP-адреса при сортировке IP-адресов. По умолчанию `false` (то есть IPv4 будет первым).

> `interleave`: number

"First Address Family count" из RFC-8305, значение по умолчанию — 1. Этот параметр определяет чередование при сортировке IP-адресов разных версий.

Например, очередь IP-адресов для набора номера будет отсортирована как 46464646 (при значении 1) или 44664466 (при значении 2) (где 6 — это IPv6-адрес, а 4 — IPv4-адрес).

> `maxConcurrentTry`: number

Максимальное количество одновременных попыток. Используется для предотвращения ситуации, когда ядро создает большое количество соединений, если разрешено много IP-адресов и ни одно из соединений не увенчалось успехом. По умолчанию 4, установка значения 0 отключает happyEyeballs.
