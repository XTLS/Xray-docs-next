# VLESS

::: danger
VLESS не предусматривает встроенного шифрования, поэтому обязательным условием для его использования является наличие надежного канала, такого как TLS или REALITY.
:::

VLESS - это легкий транспортный протокол без сохранения состояния, который разделен на входящую и исходящую части и может служить мостом между клиентом и сервером Xray.

В отличие от [VMess](./vmess.md), VLESS не зависит от системного времени, аутентификация также осуществляется с помощью UUID.


## OutboundConfigurationObject

```json
{
  "vnext": [
    {
      "address": "example.com",
      "port": 443,
      "users": [
        {
          "id": "5783a3e7-e373-51cd-8642-c83782b807c5",
          "encryption": "none",
          "flow": "xtls-rprx-vision",
          "level": 0
        }
      ]
    }
  ]
}
```

> `vnext`: \[ [ServerObject](#serverobject) \]

Массив, представляющий список серверов VLESS, содержащий набор конфигураций, указывающих на сервер, где каждый элемент является конфигурацией сервера.

### ServerObject

```json
{
  "address": "example.com",
  "port": 443,
  "users": [
    {
      "id": "5783a3e7-e373-51cd-8642-c83782b807c5",
      "encryption": "none",
      "flow": "xtls-rprx-vision",
      "level": 0
    }
  ]
}
```

> `address`: address

Адрес сервера, указывающий на сервер, поддерживаются доменные имена, IPv4 и IPv6.

> `port`: number

Порт сервера, обычно тот же, что и порт, прослушиваемый сервером.

> `users`: \[ [UserObject](#userobject) \]

Массив, представляющий список пользователей, распознаваемых сервером, где каждый элемент является конфигурацией пользователя.

### UserObject

```json
{
  "id": "5783a3e7-e373-51cd-8642-c83782b807c5",
  "encryption": "none",
  "flow": "xtls-rprx-vision",
  "level": 0
}
```

> `id`: string

Идентификатор пользователя VLESS, может быть любой строкой длиной менее 30 байт или допустимым UUID.
Пользовательская строка и ее UUID-отображение эквивалентны, это означает, что вы можете использовать следующие способы записи id в файле конфигурации для идентификации одного и того же пользователя:

- Напишите `"id": "Я люблю арбуз учителя 1314"`,
- Или напишите `"id": "5783a3e7-e373-51cd-8642-c83782b807c5"` (этот UUID является UUID-отображением строки "Я люблю арбуз учителя 1314")

Стандарт сопоставления описан в [VLESS UUID Mapping Standard: Mapping Custom Strings to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).

Вы можете использовать команду `xray uuid -i "Пользовательская строка"` для генерации UUID, соответствующего пользовательской строке. Вы также можете использовать команду `xray uuid` для генерации случайного UUID.

> `encryption`: "none"

Необходимо указать `"none"`, значение не может быть пустым.

Это требование призвано напомнить пользователю об отсутствии шифрования, а также предотвратить ошибки пользователей при вводе имени атрибута или его расположения в будущем, когда будут доступны методы шифрования.

Если значение encryption установлено неверно, при использовании Xray или -test будет выдано сообщение об ошибке.

> `flow`: string

Режим управления потоком, используется для выбора алгоритма XTLS.

В настоящее время для исходящего протокола доступны следующие режимы управления потоком:

- Отсутствует `flow` или пустая строка: используется обычный TLS-прокси.
- `xtls-rprx-vision`: используется новый режим XTLS, включает случайное заполнение внутреннего рукопожатия, поддерживает uTLS для имитации отпечатка клиента.
- `xtls-rprx-vision-udp443`: аналогично `xtls-rprx-vision`, но разрешает UDP-трафик, направленный на порт 443.

Кроме того, в настоящее время XTLS поддерживает только TCP+TLS/Reality.

<!-- prettier-ignore -->
::: tip О режимах управления потоком xtls-rprx-*-udp443

Когда XTLS в Xray-core включен, трафик, направленный на UDP-порт 443 (обычно QUIC), по умолчанию блокируется, чтобы приложение не использовало QUIC, а использовало TLS, чтобы XTLS действительно вступил в силу. Фактически, QUIC сам по себе не подходит для проксирования, поскольку QUIC имеет встроенные функции TCP, и когда он передается по протоколу VLESS как UDP-трафик, базовый протокол - TCP, что эквивалентно двум уровням TCP.

Если блокировка не требуется, укажите `xtls-rprx-*-udp443` на стороне клиента, на стороне сервера оставляйте без изменений.
:::

::: tip О режиме Splice

Splice - это функция, предоставляемая ядром Linux, где ядро системы напрямую пересылает TCP, минуя память Xray, что значительно сокращает количество операций копирования данных и переключения контекста процессора.

Ограничения использования режима Splice:

- Среда Linux.
- Входящий протокол: `Dokodemo door`, `Socks`, `HTTP` и другие чистые TCP-соединения или другие входящие протоколы, использующие XTLS.
- Исходящий протокол: VLESS + XTLS.
- Обратите внимание, что при использовании протокола mKCP Splice не будет использоваться (да, хотя ошибки и нет, на самом деле он не используется).

Кроме того, при использовании Splice отображение скорости сети будет запаздывать, это особенность, а не ошибка.

При использовании режима Vision Splice будет включен автоматически, если выполнены вышеуказанные условия.
:::

> `level`: number

Уровень пользователя, для соединения будет использоваться [локальная политика](../policy.md#levelpolicyobject), соответствующая этому уровню пользователя.

Значение level соответствует значению `level` в разделе [policy](../policy.md#policyobject). Если не указано, используется значение по умолчанию - 0.


