# Freedom (fragment, noises)

Freedom — это исходящий протокол, который можно использовать для отправки (обычных) данных TCP или UDP в любую сеть.

## OutboundConfigurationObject

```json
{
  "domainStrategy": "AsIs",
  "redirect": "127.0.0.1:3366",
  "userLevel": 0,
  "fragment": {
    "packets": "tlshello",
    "length": "100-200",
    "interval": "10-20" // единица измерения: мс
  },
  "noises": [
    {
      "type": "base64",
      "packet": "7nQBAAABAAAAAAAABnQtcmluZwZtc2VkZ2UDbmV0AAABAAE=",
      "delay": "10-16"
    }
  ],
  "proxyProtocol": 0
}
```

> `domainStrategy`: "AsIs"<br>
> "UseIP" | "UseIPv6v4" | "UseIPv6" | "UseIPv4v6" | "UseIPv4"<br>
> "ForceIP" | "ForceIPv6v4" | "ForceIPv6" | "ForceIPv4v6" | "ForceIPv4"

Значение по умолчанию — `"AsIs"`.

Когда целевым адресом является доменное имя, при настройке соответствующих значений Freedom будет вести себя следующим образом:

- При использовании `"AsIs"` Xray будет напрямую использовать встроенную функцию `Dial` из Go для установления соединения, с фиксированным приоритетом, заданным по умолчанию в RFC6724 (игнорируя такие настройки, как `gai.conf`). *(Простыми словами: IPv6 будет использоваться с приоритетом).*
По некоторым причинам, UDP-соединения при использовании доменных имен будут игнорировать системные настройки и отдавать предпочтение IPv4.

- При указании других значений для разрешения будет использоваться [встроенный DNS-сервер](../dns.md) Xray-core. Если `DNSObject` не существует, будет использоваться системный DNS. Если имеется несколько подходящих IP-адресов, ядро случайным образом выберет один из них в качестве целевого IP-адреса.
- `"IPv4"` означает попытку установить соединение, используя только IPv4, `"IPv4v6"` означает попытку соединения с использованием IPv4 или IPv6, но для доменов с двойным стеком будет использоваться IPv4.  *(Если поменять местами v4 и v6, логика остается аналогичной)*

- Если в настройках встроенного DNS указан `"queryStrategy"`, фактическое поведение будет объединено с этим параметром, и будут разрешаться только те типы IP, которые указаны в обоих параметрах. Например, `"queryStrategy": "UseIPv4"` и `"domainStrategy": "UseIP"` фактически эквивалентны `"domainStrategy": "UseIPv4"`.
- При использовании параметров, начинающихся с `"Use"`, если результат разрешения не соответствует требованиям (например, доменное имя имеет только запись A, но используется `UseIPv6`), будет выполнен откат к `AsIs`.
- При использовании параметров, начинающихся с `"Force"`, если результат разрешения не соответствует требованиям, соединение установить не удастся.

::: tip СОВЕТ 1
При использовании режимов `"UseIP"` или `"ForceIP"` и указании `sendThrough` в [конфигурации исходящего соединения](../outbound.md#outboundobject), Freedom будет автоматически определять необходимый тип IP-адреса (IPv4 или IPv6) на основе значения `sendThrough`. Если вручную указан только один тип IP-адреса (например, `UseIPv4`), но он не соответствует локальному адресу, указанному в `sendThrough`, подключение установить не удастся.
:::

> `redirect`: address_port

Freedom будет принудительно отправлять все данные на указанный адрес (а не на адрес, указанный во входящем соединении).

Значение — строка, например: `"127.0.0.1:80"`, `":1234"`.

Если адрес не указан, например `":443"`, Freedom не будет изменять исходный целевой адрес.
Если порт равен `0`, например `"xray.com: 0"`, Freedom не будет изменять исходный порт.

> `userLevel`: number

Уровень пользователя. Подключение будет использовать [локальную политику](../policy.md#levelpolicyobject), соответствующую этому уровню пользователя.

Значение `userLevel` соответствует значению `level` в [policy](../policy.md#policyobject). Если не указано, по умолчанию используется значение `0`.

> `fragment`: map

Несколько пар «ключ-значение», используемых для управления исходящей фрагментацией TCP. В некоторых случаях это может обмануть системы цензуры, например, обойти черные списки SNI.
`"length"` и `"interval"` относятся к типу [Int32Range](../../development/intro/guide.md#int32range)

`"packets"`: поддерживаются два режима фрагментации: "1-3" — фрагментация потока TCP, применяется к первым трем операциям записи данных на стороне клиента; "tlshello" — фрагментация пакета TLS-рукопожатия.

`"length"`: длина фрагмента (в байтах).

`"interval"`: интервал между фрагментами (в мс).

Если значение равно `0` и установлено `"packets": "tlshello"`, фрагментированный пакет Client Hello будет отправлен в одном TCP-пакете (если его исходный размер не превышает MSS или MTU, что приводит к автоматической фрагментации системой).

> `noises`: array

UDP-шум, используемый для отправки случайных данных в качестве "шума" перед установлением UDP-соединения.  Наличие этой структуры считается включением. Это может обмануть снифферы, но также может нарушить нормальное соединение. Используйте на свой страх и риск. По этой причине он обходит порт 53, так как это нарушает работу DNS.

Массив, в котором можно определить несколько пакетов шума для отправки. Отдельный элемент массива определяется следующим образом:

`"type"`: тип пакета шума. В настоящее время поддерживаются `"rand"` (случайные данные), `"str"` (пользовательская строка) и `"base64"` (пользовательские двоичные данные, закодированные в Base64).

`"packet"`: содержимое пакета данных, основанное на предыдущем значении `type`.

- Если `type` равен `rand`, здесь указывается длина случайных данных. Это может быть фиксированное значение, например `"100"`, или диапазон значений, например `"50-150"`.
- Если `type` равен `str`, здесь указывается строка для отправки.
- Если `type` равен `base64`, здесь указываются двоичные данные, закодированные в Base64.

`"delay"`: **задержка**, в миллисекундах. После отправки этого пакета шума ядро будет ждать указанное время, прежде чем отправить следующий пакет шума или реальные данные. По умолчанию ожидание отсутствует. Тип: [Int32Range](../../development/intro/guide.md#int32range)

> `proxyProtocol`: number

Протокол PROXY обычно используется в сочетании с `redirect` для перенаправления на сервер Nginx или другой сервер, на котором включен протокол PROXY. Если сервер не поддерживает протокол PROXY, соединение будет разорвано.

`proxyProtocol` принимает значение номера версии протокола PROXY — `1` или `2`. Если не указано, по умолчанию используется значение `0` (протокол не используется). 
