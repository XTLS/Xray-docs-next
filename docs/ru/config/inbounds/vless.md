# VLESS（XTLS Vision Seed）

::: danger
VLESS не предусматривает встроенного шифрования, поэтому обязательным условием для его использования является наличие надежного канала, такого как TLS или REALITY.
:::

VLESS - это легкий транспортный протокол без сохранения состояния, который разделен на входящую и исходящую части и может служить мостом между клиентом и сервером Xray.

В отличие от [VMess](./vmess.md), VLESS не зависит от системного времени, аутентификация также осуществляется с помощью UUID.

## InboundConfigurationObject

```json
{
  "clients": [
    {
      "id": "5783a3e7-e373-51cd-8642-c83782b807c5",
      "level": 0,
      "email": "love@xray.com",
      "flow": "xtls-rprx-vision"
    }
  ],
  "decryption": "none",
  "fallbacks": [
    {
      "dest": 80
    }
  ]
}
```

> `clients`: \[ [ClientObject](#clientobject) \]

Массив, представляющий группу пользователей, одобренных сервером.

Каждый элемент является пользователем [ClientObject](#clientobject).

> `decryption`: "none"

На данный момент необходимо указать `"none"`, значение не может быть пустым.
Если значение decryption установлено неверно, при использовании Xray или -test будет выдано сообщение об ошибке.

Обратите внимание, что здесь используется decryption, на том же уровне, что и clients.
Расположение decryption и encryption в протоколе vmess отличается, потому что, если используется дополнительный уровень шифрования, сервер должен сначала расшифровать данные, чтобы узнать, какой это пользователь.

> `fallbacks`: \[ [FallbackObject](../features/fallback.md) \]

Массив, содержащий ряд конфигураций fallback-маршрутизации (необязательно).
Подробную информацию о настройке fallbacks см. в разделе [FallbackObject](../features/fallback.md#fallbacks-конфигурация).

### ClientObject

```json
{
  "id": "5783a3e7-e373-51cd-8642-c83782b807c5",
  "level": 0,
  "email": "love@xray.com",
  "flow": "xtls-rprx-vision"
}
```

> `id`: string

Идентификатор пользователя VLESS, может быть любой строкой длиной менее 30 байт или допустимым UUID.
Пользовательская строка и ее UUID-отображение эквивалентны, это означает, что вы можете использовать следующие способы записи id в файле конфигурации для идентификации одного и того же пользователя:

- Напишите `"id": "Я люблю арбуз учителя 1314"`,
- Или напишите `"id": "5783a3e7-e373-51cd-8642-c83782b807c5"` (этот UUID является UUID-отображением строки "Я люблю арбуз учителя 1314")

Стандарт сопоставления описан в [VLESS UUID Mapping Standard: Mapping Custom Strings to a UUIDv5](https://github.com/XTLS/Xray-core/issues/158).

Вы можете использовать команду `xray uuid -i "Пользовательская строка"` для генерации UUID, соответствующего пользовательской строке.

> Вы также можете использовать команду `xray uuid` для генерации случайного UUID.

> `level`: number

Уровень пользователя, для подключения будет использоваться [локальная политика](../policy.md#levelpolicyobject), соответствующая этому уровню пользователя.

Значение level соответствует значению `level` в разделе [policy](../policy.md#policyobject). Если не указано, используется значение по умолчанию - 0.

> `email`: string

Адрес электронной почты пользователя, используется для разделения трафика разных пользователей (отображается в журналах, статистике).

> `flow`: string

Режим управления потоком, используется для выбора алгоритма XTLS.

В настоящее время для входящего протокола доступны следующие режимы управления потоком:

- Отсутствует `flow` или пустая строка: используется обычный TLS-прокси
- `xtls-rprx-vision`: используется новый режим XTLS, включает случайное заполнение внутреннего рукопожатия

Кроме того, в настоящее время XTLS поддерживает только TCP+TLS/Reality.
